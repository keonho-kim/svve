# Segmented Vector Voting & Expansion (SVVE) 이론 배경 문서

## 1. 문서 목적과 범위

이 문서는 `docs/arch/blueprint.md`를 기준으로, SVVE를 고정 절차 알고리즘으로 정의하고 수학적 작동 원리를 설명한다.

핵심 범위는 다음과 같다.

- 고정된 단계 순서로 SVVE를 정의
- PRF 확장을 필수 단계로 명시
- 고정 수치와 종료 조건(조기 종료 포함)을 명확히 규정

## 2. 문제 정의

SVVE는 "이미 임베딩이 구축된 VDB"와의 연동을 전제로 한다.

- 입력: 쿼리 벡터 `q ∈ R^d`
- 데이터: VDB 내부 문서 벡터 집합 `D = {x_1, ..., x_M}`
- 출력: 최종 Top-K 문서 ID와 점수
- 제약: 오프라인 사전 계산/이중 인덱싱 없이 동작
- 연동 인터페이스: `search_fn` 콜백 주입

SVVE의 역할은 인덱스를 바꾸는 것이 아니라, 검색 시점에 고정된 다단계 검증과 확장 루프를 실행해 결과 품질을 끌어올리는 것이다.

## 3. 고정 기호와 파라미터

- `N=4`: 세그먼트 질의 수
- `k_seg=100`: 세그먼트별 1차 검색 후보 수
- `C_i`: i번째 세그먼트 검색 결과 집합 (`i ∈ {1,2,3,4}`)
- `v(doc)`: 후보 문서의 투표 수
- `M=5`: 생존 문서 수
- `q*`: PRF 보정 쿼리
- `alpha=0.7`: 원본 쿼리 가중치 (`1-alpha=0.3`)
- `K`: 최종 목표 Top-K 개수
- `R_max=8`: 최대 재검색 라운드 수
- `tau_j=0.95`: Top-K 집합 Jaccard 조기 종료 임계치
- `tau_s=0.005`: 점수 개선율 조기 종료 임계치
- `S=2`: 조기 종료를 위한 연속 안정 라운드 수

투표 분류 규칙은 고정한다.

- `v(doc) >= 3`: Strong Candidate
- `v(doc) = 2`: Weak Candidate
- `v(doc) <= 1`: Noise (제거)

## 4. 고정 SVVE 알고리즘

### 4.1 Step 1: 논리적 벡터 분할

입력 쿼리 `q`를 4개 세그먼트 질의로 고정 분할한다.

- `q -> {q_1, q_2, q_3, q_4}`

### 4.2 Step 2: 세그먼트 검색 실행

각 세그먼트 질의를 동일 VDB 인덱스에 전송한다.

- `C_i = SearchVDB(q_i, k_seg)`
- `k_seg = 100` 고정

실행 정책은 Python `search_fn` 콜백 안정성을 위해 순차 실행이다.

### 4.3 Step 3: 투표 병합과 생존 선택

`doc_id` 기준으로 `C_1..C_4`를 병합해 투표수를 계산한다.

- `v(doc) = Σ_i 1(doc ∈ C_i)`

투표 규칙(3/2/1)을 적용해 노이즈를 제거하고, Strong/Weak를 통합 점수로 정렬한 뒤 상위 5개를 생존 문서 `R={r_1..r_5}`로 확정한다.

### 4.4 Step 4: PRF 기반 쿼리 보정 (필수)

PRF는 필수 단계다. 생존 문서 벡터 중심 `c`를 계산하고 보정 쿼리 `q*`를 만든다.

- `c = (1/M) Σ_{j=1..M} r_j`
- `q* = alpha * q + (1-alpha) * c`
- `alpha = 0.7`, `M = 5`

이 단계는 1차 검색 노이즈를 거른 뒤 신뢰 후보의 공통 문맥을 쿼리에 반영하는 역할을 한다.

### 4.5 Step 5: 확장 후 재검색/재정렬 반복 (핵심)

최종 결과 집합 `F`를 비운 상태에서 시작하고, 아래 과정을 반복한다.

1. 보정 쿼리 `q*`로 추가 검색 수행
2. 기존 후보와 신규 후보를 합쳐 재정렬 수행
3. 중복 제거 후 상위 후보를 `F`에 누적

반복 종료 조건은 다음 중 하나다.

1. `|F| >= K`
2. 조기 종료 조건 충족
3. `round == R_max`

조기 종료는 랭킹 안정화 기반으로 정의한다.

- 집합 안정화: `Jaccard(TopK_t, TopK_{t-1}) >= tau_j`
- 점수 개선율: `|sum_t - sum_{t-1}| / max(|sum_{t-1}|, 1e-6) <= tau_s`
- 위 2개가 `S` 라운드 연속 만족되면 종료

## 5. 이론 기반 파이프라인 요약

1. 쿼리 입력 검증(`numpy.float32`, 1D)
2. 4세그먼트 질의 생성
3. 세그먼트별 Top-100 검색(어댑터 정책에 따라 병렬/순차)
4. 3/2/1 투표 규칙으로 노이즈 제거 및 생존 5개 선택
5. PRF 보정 쿼리 생성(`q* = 0.7q + 0.3c`)
6. 추가 검색/후보 재정렬을 `K` 충족 또는 조기 종료까지 반복
7. `(doc_ids, scores)` SoA 배열 반환

## 6. API 인터페이스와의 연결

공개 API는 단순한 형태를 유지한다.

```python
engine = SearchEngine()
ids, scores = engine.search(query, top_k=10, search_fn=search_fn)
```

외부 인터페이스가 단순하더라도 내부는 고정된 SVVE 절차를 항상 수행한다.

- 입력 인터페이스: `float32`, 1D
- 반환 인터페이스: SoA 고정(`ids`, `scores`)
- 내부 절차: PRF 포함 고정 5단계 파이프라인

`search_fn` 인터페이스는 아래 형식을 따른다.

- 시그니처: `search_fn(query, top_k)`
- 반환: `(ids, scores, vectors)`
- 제약: `ids/scores/vectors` 길이 일치, `vectors[i]` 차원은 쿼리 차원과 동일

## 7. 고정 수치 목표

- 세그먼트 수: `N=4`
- 세그먼트 후보 수: `k_seg=100`
- 생존 문서 수: `M=5`
- PRF 계수: `alpha=0.7`
- 운영 목표: `p95 <= 100ms`, `p99 <= 150ms`
- 조기 종료 임계치: `tau_j=0.95`, `tau_s=0.005`, `S=2`
- 최대 반복 라운드: `R_max=8`

## 8. 구현 최적화 관점 (절차 불변)

### 8.1 Python 계층

- 입력 변환 최소화(`float32`, contiguous fast path)
- 엔진 객체 재사용으로 요청 핫패스 고정 비용 감소

### 8.2 Rust 계층(병렬 중심)

- `rayon` 전역 스레드풀 재사용
- 스레드 로컬 집계 후 병합으로 경합 완화
- partial top-k와 버퍼 재사용으로 재정렬 비용 절감

### 8.3 VDB 연동 계층

- 동시 요청 수 제한으로 과부하 방지
- 타임아웃/재시도 정책 분리
- I/O 지연과 CPU 병합 지연을 분리 계측

## 9. 가정과 비목표

### 가정

- 문서 벡터는 단일 임베딩 모델로 이미 VDB에 구축되어 있다.
- 검색은 단일 인덱스에서 수행된다.

### 비목표

- 오프라인 벡터 재가공 파이프라인은 본 문서 범위가 아니다.
- 별도 보조 인덱스와 이중 검색 계층은 사용하지 않는다.
